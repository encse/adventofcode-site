I modeled Part 1 following the description closely. I didn't want to introduce separate
classes for the gate types, instead I used a function parameter that map signals to signals.
I tells what should be emitted when a signal is received. I know that this is like Elf logic, 
but it's ðŸŽ„, what did you expect? I have one constructor function for each
gate type (Nand, FlipFlop and Repeater) these declare the necessary state variables
and capture it in the returned lambda. Everything is self contained, I have a single Gate type, 
yet different behavior.

I made a function that trigger the button and executes all the logic until things settle down,
it returns all signals that was emitted, so that I can work with it both in Part 1 and Part 2.

Part 2 is a _reverse engineering_ problem, we need to tell how many times the button need to
be pressed until a single high value is emitted in the rx gate. 

I layed out the graph using Graphviz just to see what's going on. This immediately showed that 
`broadcaster` feeds four different subgraphs. These work in isolation and a Nand gate connects 
their output into `rx`. Further investigation shows that each subgraph runs in an endless loop 
that has prime length (at least for  my input). We just need to measure these and multiply 
them together to solve the second half of the problem.
